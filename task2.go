package main

import (
	"context"
	"crypto/ecdsa"
	"fmt"
	"log"
	"math/big"
	"os"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/local/go-eth-demo/counter"
)

func DeployCounter() {
	// Read RPC URL from environment (loaded from .env in main)
	url := os.Getenv("ETH_NODE_URL")
	if url == "" {
		log.Fatalf("ETH_NODE_URL is not set. Create a .env file or export the env var before running.")
	}

	// Connect to an Ethereum node
	client, err := ethclient.Dial(url)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}
	defer client.Close()

	privateKeyHex := os.Getenv("PRIVATE_KEY")
	if privateKeyHex == "" {
		log.Fatalf("PRIVATE_KEY is not set. Create a .env file or export the env var before running.")
	}

	privateKey, err := crypto.HexToECDSA(privateKeyHex)
	if err != nil {
		log.Fatalf("Invalid private key: %v", err)
	}

	publicKey := privateKey.Public()
	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
	if !ok {
		log.Fatalf("Cannot assert type: publicKey is not of type *ecdsa.PublicKey")
	}

	fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
	nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
	if err != nil {
		log.Fatalf("Failed to get nonce: %v", err)
	}

	gasPrice, err := client.SuggestGasPrice(context.Background())
	if err != nil {
		log.Fatalf("Failed to get gas price: %v", err)
	}

	chainID, err := client.NetworkID(context.Background())
	if err != nil {
		log.Fatalf("Failed to get chain ID: %v", err)
	}

	// Note: The actual contract deployment code is commented out because it requires
	// the generated Go bindings from the Solidity contract.

	// Load the contract's ABI and bytecode
	// Assuming the contract package is named "counter" and has been generated by abigen
	// import "path/to/your/counter"
	// Replace with actual import path

	auth, err := bind.NewKeyedTransactorWithChainID(privateKey, chainID)
	if err != nil {
		log.Fatalf("Failed to create transactor: %v", err)
	}
	auth.Nonce = big.NewInt(int64(nonce))
	auth.Value = big.NewInt(0)      // in wei
	auth.GasLimit = uint64(3000000) // in units
	auth.GasPrice = gasPrice

	// Deploy the contract
	address, tx, instance, err := counter.DeployCounter(auth, client)
	if err != nil {
		log.Fatalf("Failed to deploy contract: %v", err)
	}

	fmt.Printf("Contract deployed! Address: %s\n", address.Hex())
	fmt.Printf("Transaction hash: %s\n", tx.Hash().Hex())

	_ = instance // Use the instance to interact with the contract after deployment
}

func InteractWithCounter() {
	// Read RPC URL from environment (loaded from .env in main)
	url := os.Getenv("ETH_NODE_URL")
	if url == "" {
		log.Fatalf("ETH_NODE_URL is not set. Create a .env file or export the env var before running.")
	}

	// Connect to an Ethereum node
	client, err := ethclient.Dial(url)
	if err != nil {
		log.Fatalf("Failed to connect to the Ethereum client: %v", err)
	}
	defer client.Close()

	privateKeyHex := os.Getenv("PRIVATE_KEY")
	if privateKeyHex == "" {
		log.Fatalf("PRIVATE_KEY is not set. Create a .env file or export the env var before running.")
	}

	privateKey, err := crypto.HexToECDSA(privateKeyHex)
	if err != nil {
		log.Fatalf("Invalid private key: %v", err)
	}

	publicKey := privateKey.Public()
	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
	if !ok {
		log.Fatalf("Cannot assert type: publicKey is not of type *ecdsa.PublicKey")
	}

	fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
	nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
	if err != nil {
		log.Fatalf("Failed to get nonce: %v", err)
	}

	gasPrice, err := client.SuggestGasPrice(context.Background())
	if err != nil {
		log.Fatalf("Failed to get gas price: %v", err)
	}

	chainID, err := client.NetworkID(context.Background())
	if err != nil {
		log.Fatalf("Failed to get chain ID: %v", err)
	}

	auth, err := bind.NewKeyedTransactorWithChainID(privateKey, chainID)
	if err != nil {
		log.Fatalf("Failed to create transactor: %v", err)
	}
	auth.Nonce = big.NewInt(int64(nonce))
	auth.Value = big.NewInt(0)     // in wei
	auth.GasLimit = uint64(300000) // in units
	auth.GasPrice = gasPrice

	contractAddrHex := os.Getenv("COUNTER_ADDRESS")
	if contractAddrHex == "" {
		log.Fatalf("COUNTER_ADDRESS is not set. Create a .env file or export the env var before running.")
	}
	contractAddress := common.HexToAddress(contractAddrHex)

	// Load the contract instance
	instance, err := counter.NewCounter(contractAddress, client)
	if err != nil {
		log.Fatalf("Failed to load contract instance: %v", err)
	}

	// Read the current count (call, no gas)
	beforeIncrement, err := instance.Count(&bind.CallOpts{Context: context.Background()})
	if err != nil {
		log.Fatalf("Failed to call Count method: %v", err)
	}
	fmt.Printf("Counter Value Before Increment: %d\n", beforeIncrement)

	// Call the Increment method (state-changing)
	tx, err := instance.Increment(auth)
	if err != nil {
		log.Fatalf("Failed to call Increment method: %v", err)
	}
	fmt.Printf("Increment transaction sent: %s\n", tx.Hash().Hex())

	// Wait for the transaction to be mined
	bind.WaitMined(context.Background(), client, tx)
	time.Sleep(15 * time.Second) // Wait for a while to ensure the state is updated

	// query after increment
	afterIncrement, err := instance.Count(&bind.CallOpts{Context: context.Background()})
	if err != nil {
		log.Fatalf("Failed to call Count method: %v", err)
	}
	fmt.Printf("Counter Value After Increment: %d\n", afterIncrement)
}
